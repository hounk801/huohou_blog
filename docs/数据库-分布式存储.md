![image.png](https://www.hounk.world/upload/2021/01/image-813a94b86bff4a43b7e14d622d241ffc.png)

# 1、MySQL 数据库复制
## 1.1 作用
1. 可以实时灾备，用于故障切换；
2. 读写分离，提供查询服务，实现负载均衡；
3. 数据热备，避免影响业务。

## 1.2 原理
### 1.2.1 异步复制
![image.png](https://www.hounk.world/upload/2021/03/image-8220052338a04fc8a925756b1381ee69.png)
如图，整个过程涉及三个 Thread，分别是 Master 的 Binlog Dump Thred，和 Slave 的 I/O Thread 和 SQL Thread：
1. Master 服务器上对数据库的变更操作记录在 Binlog 中。
2. Master 的 Binlog Dump Thread 接到写入请求后读取 Binlog 推送给 Slave I/O Thread。
3. Slave I/O Thread 将读取的 Binlog 写入到本地 relay log 文件。
4. Slave SQL thread 检测到 relay log 的变更请求，解析 relay log 并在从库上进行应用。

以上整个复制过程都是异步操作，所以主从复制俗称异步复制，存在数据延迟。

Master 数据变更后记录 Binlog，只是通知 Binlog Dump Thread 有数据写入后就告诉存储引擎提交事务，并不会关注 Slave 是否接受并落地 Binlog Event。下图是异步复制的时序图。
![image.png](https://www.hounk.world/upload/2021/03/image-efcf132bf5f64ba8a7eabc2a2f0cf063.png)

考虑到一个场景，主库正常写入数据并提交事务 T1，但是 Slave1 和 Slave2 由于某种原因（例如网络原因）一直无法接受到 Binlog Dump Thread Event 的推送请求，如果这时候 Master Crash，Slave 提升为 Master 后导致事务 T1 数据丢失。为了提升数据安全，MySQL 让 Master 在某一个时间点等待 Slave 节点的 ACK 消息后才进行事务提交，这也是半同步复制的基础。

MySQL 从 5.5 版本开始引入了半同步复制机制来降低数据丢失的概率，为什么是降低呢？原因除了 MySQL 半同步复制会退化成异步复制之外，还需要讲下半同步复制after commit 和增强半同步 after-sync 的实现。

 
MySQL 事务写入碰到主从复制时的完整过程，主库事务写入分为 4 个步骤：
1. InnoDB Redo File Write (Prepare Write)；
2. Binlog File Flush & Sync to Binlog File；
3. InnoDB Redo File Commit（Commit Write）；
4. Send Binlog to Slave。
当 Master 不需要关注 Slave 是否接受到 Binlog Event 时，即为传统的主从复制。
当 Master 需要在第三步等待 Slave 返回 ACK 时，即为 after-commit。
当 Master 需要在第二步等待 Slave 返回 ACK 时，即为 after-sync。
#### 1.2.1.1 after-commit

MySQL Master 将事务写入 Binlog（sync_binlog=1）并推送给 Slave 后主库将事务提交到存储引擎（此时未返回客户端但是其他会话可以访问到事务提交信息），Slave  I/O Thread 将读取的 Binlog 写入到本地 relay log 文件（sync_relay=1）后向 Master 返回 ACK 消息，当主库 Master 等到 Slave 返回的 ACK 消息后 Master 将事务提交成功的结果返回给客户端。

对于当前会话的客户端进行事务提交后，主库等待 ACK 的过程中有两种情况。
1. 事务还没发送到从库，主库 crash 并发起切换，从库为新主库。客户端收到事务提交失败的信息，需要重新提交该事务。
2. 事务已经发送到从库，主库 crash 并发起切换，从库为新主库。从库已经应用该事务并写入数据，但客户端连接重置同样会收到事务提交失败的信息，重新提交该事务时会报错数据已存在（如订单已提交成功）。

after-commit 的情况在非当前客户端访问数据时会出现“数据幻读”的情况，例如User1 想在 t1 表插入记录 3 并在存储引擎层提交事务，此时 User2 可以看到已经提交事务的数据记录 3。当时 Master 在等待 Slave 返回 ACK 的过程中 Crash 了并且 Slave也没有成功接受到 Binlog Event，此时 Slave 提升为 Master 时 User2 发现之前访问到的数据记录 3 又不见了。如果 Master Crash 后无法启动，那么提交的事务记录 3 在从库上永远找不到了，导致数据丢失。

#### 1.2.1.2 after-sync
为了提升数据的安全性，MySQL 5.7 引入了增强半同步 after_sync（无损复制），并将其设置为默认的半同步方式来解决数据丢失的问题。after-sync 是将 Master 等待 ACK 消息放到了 Binlog File Flush & Sync to Binlog File 之后，Engine Commit 之前，这样就可以保证数据不会丢失，因为 Slave 接受到event 并写入自身 relay log。

对于数据安全的场景，参数 innodb_flush_log_at_trx_commit【[参考](https://www.hounk.world/archives/shi-wu) 】和 sync_log 均配置1，配合 after-sync 半同步模式是一个好的选择，这也是大部分金融场景的参数配置。

下图是 MySQL 官方对于半同步复制的时序图，主库等待从库写入 relay log 并返回 ACK 后才进行 Engine Commit。    
![image.png](https://www.hounk.world/upload/2021/03/image-e3511ba02dfb40edb0f4eb3dae1951e0.png)

### 1.2.2 同步复制（准同步）
#### 1.2.2.1 Galera Cluster

通常由三个实例组成的一个集群，三个节点均可以提供读写，即常见的多主架构。客户端可以读写访问集群任意一个节点，集群节点间组成了Group communication。这可以用来保证集群节点数据的强一致性，这种架构是不共享数据、多副本的高冗余架构，拥有多点写入、同步复制、无复制延迟、并发复制、随意切换、节点自动配置、健康检查等功能。
![image.png](https://www.hounk.world/upload/2021/03/image-b0784b06376143a184676c79fe2fbe25.png)

Group communication 的本质是 Galera Cluster，它来实现强一致性、支持多点写入的同步复制集群架构，Galera Cluter 提供了一系列的 API，为上层 MySQL 提供丰富的状态信息及回调函数，API 即 Write-Set Replication API，简称 wsrep API。通过这些API 来提供基于写集验证的乐观锁的同步复制，当一个节点组装完写集后，每个节点在复制事务时都会在组内广播写集并进行写集比对，如果没有冲突的话，那么 Galera Cluster 层对该写集对应的事务就可以继续提交或 APPLY，当数据库 MySQL 层得到Galera Cluster 层返回的回调状态信息后继续事务提交或回滚的操作。

Galera Cluster是一个强一致性集群，当集群节点有数据写入时，Group communication 会向组内所有成员广播写集（初步可简单理解为写入的Binlog），所有节点验证通过之后写节点开始提交，其他节点执行写集应用和提交，当出现数据冲突时则写节点执行回滚，其他节点丢弃该写集。

#### 1.2.2.2 MySQL Group Replication
MySQL 在 5.7 版本参考 Galera Cluster 的技术实现推出了 MySQL Group Replication（简称 MGR）。MGR 同样是一个支持多点写入的多主复制架构，它基于原生 MySQL 主从复制的基础上构建组通信层，由 Group Replication 提供一组原子消息并且按照全局顺序进行消息传递，集群任何节点均可写入，但所有写入事务只有在获得复制组认证通过【多数派协议 [Paxos](https://www.hounk.world/archives/p-a-x-o-s-suan-fa)】后才能进行提交。例如由若干个节点共同组成一个复制组，一个事务的提交必须经过组内大多数节点（N / 2 + 1）决议并通过，才能得以提交。     

如下是 MySQL Group Replication /Galera Cluster 的时序图：由 3 个节点组成一个复制组，Consensus 层为一致性协议层，在事务提交过程中，发生组间通信，由 2 个节点决议（certify）通过这个事务，事务才能够最终得以提交并响应。        
![image.png](https://www.hounk.world/upload/2021/03/image-169ba275440a47c2be2dc8f12a282a9a.png)

## 1.3 主从复制
就是将 MySQL 主数据库中的数据复制到从数据库中去。主要目的是实现数据库读写分离——写操作访问主数据库，读操作访问从数据库，从而使数据库具有更强大的访问负载能力，支撑更多的用户访问。

这样当客户端应用程序执行一个 update 命令的时候，这个命令会在主数据库和从数据库上同步执行，从而实现了主数据库向从数据库的复制，让从数据库和主数据库保持一样的数据。
### 1.3.1 一主多从
MySQL 的主从复制是一种数据同步机制，除了可以将一个主数据库中的数据同步复制到一个从数据库上，还可以将一个主数据库上的数据同步复制到多个从数据库上。
#### 1.3.1.1 分摊负载
将只读操作分布在多个从数据库上，从而将负载分摊到多台服务器上。
一般说来，对数据库做主从复制的时候，通常是为了进行读写分离，数据库的写操作在主数据库上，读操作在从服务器上进行，这样把读写两部分操作分别交给不同的服务器去处理，降低数据库的负载压力，而使用更多的从数据库向应用程序提供读服务，更好地减轻了整个数据库的访问压力。

#### 1.3.1.2 专机专用
可以针对不同类型的查询，使用不同的从服务器。比如有一台服务器专门用来做应用程序的读操作，另一个服务器专门用来执行数据报表类的操作，还有的服务器可能专门执行数据备份。通过这样的方式，将不同的操作连接到不同的从数据库上，从而实现了专机专用，也进一步改善了用户的体验。

#### 1.3.1.3 便于冷备
#### 1.3.1.4 高可用

如果一台服务器宕机了，只要不发请求给这台服务器就不会出问题。当这台服务器恢复的时候，再重新发请求到这台服务器。所以，在一主多从的情况下，某一台从服务器宕机不可用，对整个系统的影响是非常小的。

### 1.3.2 主主复制
主数据库宕机不可用的时候，数据依然是不能够写入的，因为数据不能够写入到从服务器上面去，从服务器是只读的。 

为了解决主服务器的可用性问题，可以使用 MySQL 的主主复制方案。所谓的主主复制方案是指两台服务器都当作主服务器，任何一台服务器上收到的写操作都会复制到另一台服务器上。 

当客户端程序对主服务器 A 进行数据更新操作的时候，主服务器 A 会把更新操作写入到 Binlog 日志中，然后 Binlog 会将数据日志同步到主服务器 B，写入到主服务器的 Relay log 中，然后执行 Relay log，获得 Relay log 中的更新日志，执行 SQL 操作写入到数据库服务器 B 的本地数据库中。B 服务器上的更新也同样通过 Binlog 复制到了服务器 A 的 Relay log 中，然后通过 Relay log 将数据更新到服务器 A 中。
通过这种方式，服务器 A 或者 B 任何一台服务器收到了数据的写操作都会同步更新到另一台服务器，实现了数据库主主复制。主主复制可以提高系统的写可用，实现写操作的高可用。

## 1.4MySQL复制的注意事项

* 不要对两个数据库同时进行数据写操作，因为这种情况会导致数据冲突。两个服务器对同一条记录进行写操作，互相进行数据复制的时候，数据库就不知道哪条数据是正确的。

* 复制只是增加了数据的读并发处理能力，并没有增加写并发的能力和系统存储能力。因为数据复制后，所有的数据库存储的数据都是一样的，不管是主主复制，还是主从复制。如果存储资源不足、磁盘不够大，数据复制后，即使写到多个服务器上，存储依然是不够用的。同时，它也没有增加写并发能力，即使使用主主复制，应用程序一个时间内也只能向一个数据库写入。
* 更新数据表的结构会导致巨大的同步延迟。比如要在一张表中增加一个字段，要执行一个 ALTER TABLE 操作，这个操作会导致同步延迟巨大，因为该操作会阻塞其它的 Binlog 日志同步，这时候主数据库的很多写操作都无法同步到从数据库上面去，导致数据不一致。所以在实践中需要更新表结构的操作，不要写入到 Binlog 中，也就是关闭更新表结构的 Binlog。如果要对表结构进行更新，应该有运维工程师 DBA 对所有主从数据库分别手动进行数据表结构的更新操作。

# 2、数据分片
数据复制只能提高数据读并发操作能力，并不能提高数据写操作并发的能力以及数据整个的存储容量。如果我们数据库的写操作也有大量的并发请求需要满足，或者是我们的数据表特别大，那就需要进行数据分片了。 

数据分片的主要目标是，将一张数据表切分成较小的片，不同的片存储到不同的服务器上面去，通过分片的方式使用多台服务器存储一张数据表，避免一台服务器记录存储处理整张数据表带来的存储及访问压力。

## 2.1 特点
1. 数据库服务器之间互相独立，不共享任何信息，即使有部分服务器故障，也不影响整个系统的可用性。
2. 通过分片键定位分片，也就是说一个分片存储到哪个服务器上面去，到哪个服务器上面去查找，是通过分片键进行路由分区算法计算出来的。在 SQL 语句里面，只要包含分片键，就可以访问特定的服务器，而不需要连接所有的服务器，跟其他的服务器进行通信。


## 2.2 数据分片的原理与实现
分片的主要原理是将数据以某种方式进行切分，通常就是用分片键的路由算法。通过分片键，根据某种路由算法进行计算，使每台服务器都只存储一部分数据。 

### 2.2.1 硬编码
假设数据库将数据表根据用户 ID 进行分片，分片的逻辑是用户 ID 为奇数的数据存储在服务器 2 中，用户 ID 为偶数的数据存储在服务器 1 中。那么，应用程序在编码的时候，就可以直接通过用户 ID 进行哈希计算，通常是余数计算。如果余数为奇数就连接到服务器 2 上，如果余数为偶数，就连接到服务器 1 上，这样就实现了一张用户表分片在两个服务器上。

**缺点**
数据库的分片逻辑是应用程序自身实现的，应用程序需要耦合数据库分片逻辑，不利于应用程序的维护和扩展。

### 2.2.2 外置存储映射关系
就是将映射关系存储在外面。如下图所示，应用程序进行 SQL 操作的时候，通过查找外部的数据存储查询自己应该连接到哪台服务器上面，根据返回的服务器的编号，连接对应的服务器执行相应的操作。
![image.png](https://www.hounk.world/upload/2021/01/image-069ea83df3654cf894c0d9a18852912e.png)
**缺点**
* 需要额外的代码，业务逻辑因此变得复杂；
* 无法执行分片的联合操作，也就是执行查询操作的时候，只能在一个分片上进行。多个分片多张表进行 join 联合查询这种操作，分片技术是无法实现的。
* 无法使用数据库的事务。数据库事务是通过数据库自身的日志实现，数据库将多个更新操作，当做一个事务来执行，要么全部完成，要么完全不执行。但是如果通过分片的方式，不同的数据操作落在不同的服务器上，不同的服务器之间是无法实现所有的更新操作全部完成或者全部不执行的，因此也就无法使用数据库的事务。
 
### 2.2.3 分布式数据库中间件
比如Mycat。Mycat 是一个专门的分布式数据库中间件，应用程序像连接数据库一样去连接 Mycat，而数据分片的操作完全交给了 Mycat 去完成。假如有 3 个分片数据库服务器dn1、dn2 和 dn3，它们的分片规则是根据 prov 字段进行分片。那么，当我们执行一个查询操作“select * from orders where prov='wuhan'”的时候，Mycat 会根据分片规则将这条 SQL 操作路由到 dn1 这个服务器节点上。dn1 执行数据查询操作返回结果后，Mycat 再返回给应用程序。通过使用 Mycat 这样的分布式数据库中间件，应用程序可以透明地、无感知地使用分片数据库。同时，Mycat 还一定程度上支持分片数据库的联合 join 查询以及数据库事务。

## 2.3 分片数据库的伸缩扩容
随着数据的不断增长，需要更多的服务器。在增加服务器的过程中，分片规则需要改变。分片规则改变后，以前写入到原来的数据库中的数据，根据新的分片规则，可能要访问新的服务器，所以还需要进行数据迁移。

不管是更改分片的路由算法规则，还是进行数据迁移，都是一些比较麻烦和复杂的事情。因此在实践中通常的做法是数据分片使用逻辑数据库，也就是说一开始虽然只需要两个服务器就可以完成数据分片存储，但是依然在逻辑上把它切分成多个逻辑数据库。

在下图所示的例子中，将数据库切分成 32 个逻辑数据库，但是开始的时候把 32 个数据库分别启动在两个物理服务器上面。那么，路由算法就还是按照 32 进行路由分区，数据分片也是 32 片。当两台服务器不能够满足要求，只需要将这些逻辑数据库迁移到其他的物理服务器上就可以完成扩容。因为迁移后数据分片还是 32 片，数据分片的算法不需要改变。数据迁移也仅仅是将逻辑数据库迁移到新的服务器上面去，而这种迁移通过数据库的主从复制就可以完成。
![image.png](https://www.hounk.world/upload/2021/01/image-4ff087b59d8049d5a340162749a7fff2.png)
 

节选自：https://t5.lagounews.com/uR12RwRxcOE20
