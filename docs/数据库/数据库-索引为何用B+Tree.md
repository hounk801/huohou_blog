# 1、介绍

索引（Index）是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构。它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
# 2、分类
单列索引：
* 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
* 唯一索引：索引列中的值必须是唯一的，但是允许为空值，
* 主键索引：是一种特殊的唯一索引，不允许有空值。

组合索引
        在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

全文索引
       全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。

# 3、创建/删除索引
```sql
-- 创建单列普通索引
CREATE INDEX index_name ON table_name(列名)
ALTER TABLE table_name ADD INDEX index_name (列名)

-- 创建单列唯一索引
CREATE UNIQUE INDEX index_name ON table(列名)

-- 创建全文索引
CREATE FULLTEXT INDEX index_name ON table(column(length))

-- 创建联合索引
ALTER TABLE table_name ADD INDEX index_name (列1,列2);

-- 删除索引
DROP INDEX index_name ON table
```
# 4、存储结构
> d 大于1的正整数，为树的度，h 正整数，为数的高度

## 4.1 B-Tree

为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：
1. 每个结点的子结点个数≤d
2. 根结点若不是叶子结点，它至少有两个子结点
3. 除根和叶子结点外，每个结点的子结点个数≥ [d/2]
4. 所有的叶子结点都出现在同一层，而且不带有信息
5. 非叶子结点若具有j+1个子结点，那么它包含j个关键字(其中，j≤d-1)
6. 每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d ？
7. 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。？
8. 所有叶节点具有相同的深度，等于树高h。
9. 一个节点中的key从左到右非递减排列。
10. B-树的非叶子结点的结构形式:
![image.png](https://github.com/oh-huohou/huohou.blog/blob/main/image/image-d052062fb7f9428a8036f5f7243039a9.png)
ki (1≤i≤j)是关键字，所有关键字的值是唯一的;pi (0≤i≤j)是指向该结点的子结点的指针。例如图中的P1，它指向的子树的关键字应该大于k1，小于k2

一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。

## 4.1 B+Tree
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构。有几点不同的地方：
1. 非叶子结点的子树指针与关键字个数相同
2. 为所有叶子结点增加一个链指针
3. 所有关键字都在叶子结点出现

在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

其操作和B树的操作是类似的，不过需要注意的是，在增加值的时候，如果存在满员的情况，将选择结点中的值作为新的索引，还有在删除值的时候，索引中的关键字并不会删除，也不会存在父亲结点的关键字下沉的情况，因为那只是索引。

## 4.2 B Tree和B+ Tree的区别
1. 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。而且B+树叶子结点上还存储了指向与该结点相邻的后一个叶子结点的指针信息，这主要是为了加快检索多个相邻叶子结点的效率考虑。
2. 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。
用处不用：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引

## 4.3 非聚集索引（MyISAM）

叶子节点只会存储数据行的指针，简单来说数据和索引不在一起，就是非聚集索引。主键索引和辅助索引都会存储指针的值。

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 

在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

## 4.4 聚集索引（InnoDB）
聚集索引的叶子节点会存储数据行，也就是说数据和索引是在一起。辅助索引只会存储主键值。
InnoDB就是聚集索引。在InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：
```
show variables like 'innodb_page_size';
```

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。
1. InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
2. InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域，所以主键不宜过大，越小越好。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

> 一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3 ）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

## 4.5 InnoDB与MyIASM
InnoDB 存储引擎主要有如下特点：
1. 支持事务
2. 支持 4 个级别的事务隔离
3. 支持多版本读
4. 支持行级锁
5. 读写阻塞与事务隔离级别相关
6. 支持缓存，既能缓存索引，也能缓存数据
7. 整个表和主键以 Cluster 方式存储，组成一颗平衡树

MyIASM（该引擎在5.5前的MySQL数据库中为默认存储引擎）特点：
1. MyISAM没有提供对数据库事务的支持
2. 不支持行级锁和外键，导致当执行 INSERT 插入或 UPDATE 更新语句时，即执行写操作需要锁定整个表，所以会导致效率降低
3. MyISAM 保存了表的行数，当执行 SELECT COUNT(*) FROM TABLE 时，可以直接读取相关值，不用全表扫描，速度快。

# 5、注意事项

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如:
1. 知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大；Key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致 索引树的页数目变多，索引层次增加，从而影响整体查询变更的效 率。
2. 用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

# 6、为什么使用B+Tree
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。
## 6.1 内存
内存又称主存，是CPU能直接寻址访问的存储空间。在计算机工作的时候，所有的数据都要先经过内存，然后才能交由处理器去处理，内存也被称为，CPU与外存通信的桥梁。它的特点是读写速度快。在这里我们只需记住它是CPU直接寻址访问。

## 6.2 磁盘

索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。

盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。

当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。

详见[磁盘百科](https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8/2386684)

## 6.3 局部性原理与磁盘预读
由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几十万到百万分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：
* 当一个数据被用到时，其附近的数据也通常会马上被使用。
* 程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
摘自[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

## 6.4 B+Tree的性能分析

根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：
* 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

\log_2 10

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(\log_d N)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

综上所述，用B-Tree作为索引结构效率是非常高的。

而[红黑树](https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91)这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：
> dmax=floor(pagesize/(keysize+datasize+pointsize))

floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。

# 7、优化
[<站内跳转>](https://www.hounk.world/archives/m-y-s-q-l-cha-xun-you-hua)

部分图文来源及参考：
http://blog.codinglabs.org/articles/theory-of-mysql-index.html
https://www.cnblogs.com/coder2012/p/3330311.html
https://nicky-chin.cn/2018/11/17/btree-info/
