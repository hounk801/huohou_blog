# 缓存穿透
查询一个不存在的数据，缓存层和存储层都不会命中。出于容错的考虑，如果存储层查不到数据则不写入缓存层。这个过程可分为三步：
1. 缓存层不明中；
2. 存储层不命中，不将空结果写回缓存；
3. 返回空结果。

缓存穿透导致不存在的数据每次都要到存储层查询，失去了缓存保护后端的意义。穿透的原因有两个。第一，自身业务代码问题；第二遭到恶意攻击。
## 解决方案
**1.缓存空对象**

缓存不命中后，将空对象保留到缓存。

缓存空对象会有两个问题：
I 空值做了缓存意味着缓存层中存了更多的键，需要更多的内存空间，如果是攻击问题会更严重。最好是针对这类数据设置一个较短的缓存失效时间。
II 缓存层和存储层数据会有一段时间不一致。此时可以利用消息系统或者异步线程去读数据库更新缓存。

**2.布隆过滤器**
提供了一个能迅速判断请求是否有效的拦截机制，利用布隆过滤器，内部维护一系列合法有效的key，迅速判断出请求所携带的Key是否合法有效。如果不合法，则直接返回。问题是有一定的误判率。

# 缓存雪崩
缓存层因为某些原因不能提供服务，比如缓存层服务宕机，或者设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期。于是所有的请求都会到达存储层，从而存储层异常
## 解决方案：
1.给缓存的失效时间加上一个随机值，避免集体失效。
2.保证缓存层服务高可用性。例如Redis的Sentinel和Cluster

# 无底洞
无底洞现象只有在数据量非常大的时候才会出现。原因就是数据量和访问量的持续增长，造成需要大量节点做水平扩容，导致键值分布到更多的节点上，所以批量操作通常需要从不同节点上获取，分布式的批量操作会涉及多次网络时间。
问题分析：
1. 客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。
2. 网络连接数变多，对节点的性能也有一定的影响。
## 解决方案

| 方案        |优点        | 缺点        | 网络IO|
|:-----------:|:-------------:|:-------------:|:-------:|
| 串行命令 | 1.编程简单 2.如果少量keys，性能可以满足要求|大量keys请求延迟严重|O(keys)|
| 串行IO |1.编程简单  2.少量节点，性能满足要求|大量node延迟严重|O(nodes)
|并行IO|利用并行特性，延迟取决于最慢的节点|1.编程复杂 2.由于多线程，问题定位可能较难|O(max_slow(nodes))|
hash_tag|性能最高|1. 业务维护成本较高 2.容易出现数据倾斜|O(1)
