# 虚拟机

java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际
不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行
比如kotlin、scala等。
# 1.JVM的基本结构
JVM由三个主要的子系统构成

- 类加载子系统
- 运行时数据区（内存结构）
- 执行引擎
# 2.类加载机制
## 2.1类的生命周期
![image.png](https://www.hounk.world/upload/2020/12/image-a5ce29a752824baaa7f0930bd66dd59b.png)
1.加载
将.class文件从磁盘读到内存
2.连接
2.1验证
验证字节码文件的正确性
2.2准备
给类的静态变量分配内存，并赋予默认值
2.3解析
类装载器装入类所引用的其他所有类
3.初始化
为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是代码中为变量分配的真正的初始值，执行静态代码块
4.使用
5.卸载
## 2.2类加载器的种类

- 启动类加载器(Bootstrap ClassLoader)

负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等

- 扩展类加载器(Extension ClassLoader)

负责加载JRE扩展目录ext中jar类包

- 系统类加载器(Application ClassLoader)

负责加载ClassPath路径下的类包

- 用户自定义加载器(User ClassLoader)

负责加载用户自定义路径下的类包
## 2.3类加载机制
### 2.3.1全盘负责委托机制
当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入
### 2.3.2双亲委派机制
指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类
### 2.3.3双亲委派模式的优势

- 沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改
- 避免类的重复加载：当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次 
# 3运行时数据区
## 3.1方法区
类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的
信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)
## 3.2堆
虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内
存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。
### 3.2.1新生代
类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。
新生代分为两部分：伊甸区（Eden space）和幸存者区（Survivor space），所有的类都是在伊甸区被new出来的。
幸存区又分为From和To区。当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回
收（Minor GC），将Eden区中的不再被其它对象应用的对象进行销毁。然后将Eden区中剩余的对象移到From
Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区。
### 3.2.2老年代
新生代经过多次GC仍然存活的对象移动到老年区。若老年代也满了，这时候将发生Major GC（也可以叫Full GC），
进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出OOM（OutOfMemoryError）异常
### 3.2.3元空间
在JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用
的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。
## 3.3栈(Stack)
Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量
表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一
致
## 3.4本地方法栈(Native Method Stack)
和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记native方法，在Execution Engine执行时加载本地方法库
## 3.5程序计数器(Program Counter Register)
就是一个指针，指向方法区中的方法字节码（用来存储指向吓一跳指令的地址，也即将要执行的指令代码），由执行
引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计
# 4.GC算法和收集器
## 4.1如何判断对象可以被回收
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的
对象）
### 4.1.1引用计数法
给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0
的对象就是不可能再被使用的。
这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对
象之前相互循环引用的问题。所谓对象之间的相互引用问题，通过下面代码所示：除了对象a和b相互引用着对方之
外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器
法无法通知GC回收器回收它们。
### 4.1.2可达性分析算法
这个算法的基本思想就是通过一系列的称为”GC Roots“的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。
GC Roots根节点：类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等
## 4.2垃圾回收算法
### 4.2.1标记-清除算法
分为两个阶段，“标记”和”清除“。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它有两个不足的地方：
1. 效率问题，标记和清除两个过程的效率都不高；
2. 空间问题，标记清除后会产生大量不连续的碎片；
### 4.2.2复制算法
为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。当这一块的内存
使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内
存区间的一半进行回收
### 4.2.3标记-整理算法
根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存
### 4.2.4分代收集算法
现在的商用虚拟机的垃圾收集器基本都采用"分代收集"算法，这种算法就是根据对象存活周期的不同将内存分为几
块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃
圾收集。而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或者“标记-整理”算法进行垃圾收集
## 4.3垃圾收集器
java虚拟机规范对垃圾收集器应该如何实现没有任何规定，因为没有所谓最好的垃圾收集器出现，更不会有万金油垃
圾收集器，只能是根据具体的应用场景选择合适的垃圾收集器。
并行和并发概念补充：

- 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序

在继续运行，而垃圾收集器运行在另一个CPU上。
### Serial收集器
串行 单线程
进行工作时暂停其他所有工作的线程
新生代采用复制算法，老年代采用标记-整理算法
### ParNew收集器
Serial的多线程版本
### Parallel Scavenge收集器(JDK1.8)
多线程
新生代采用复制算法，老年代采用标记-整理算法
### CMS收集器
获取最短停顿时间为目标
是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程基本上同时工作
标记-清除算法
收集步骤：

1. 初始标记（CMS initial mark）：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快
1. 并发标记（CMS concurrent mark）：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶

段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC
线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

3. 重新标记（CMS remark）：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生

变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶
段时间短

4. 并发清除（CMS concurrent sweep）：开启用户线程，同时GC线程开始对为标记的区域做清扫。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1676674/1600658600897-1337270b-a179-4a25-a1b6-a762aa27d744.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image.png&originHeight=235&originWidth=540&size=55608&status=done&style=none&width=540)
CMS主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：

- 对CPU资源敏感；
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
### G1收集器
G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足
GC停顿时间要求的同时,还具备高吞吐量性能特征.
**特点：**

- 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-

The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方
式让java程序继续执行

- 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
- 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的
- 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追

求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内
**G1收集器的运作大致分为以下几个步骤：**

1. 初始标记
1. 并发标记
1. 最终标记
1. 筛选回收

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名
字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间
内可以尽可能高的收集效率（把内存化整为零）。


参考：
[http://www.ityouknow.com/jvm/2017/09/18/GC-Analysis.html](http://www.ityouknow.com/jvm/2017/09/18/GC-Analysis.html)
[https://tech.meituan.com/2017/12/29/jvm-optimize.html](https://tech.meituan.com/2017/12/29/jvm-optimize.html)
[https://www.codenong.com/cs106827648/](https://www.codenong.com/cs106827648/)
