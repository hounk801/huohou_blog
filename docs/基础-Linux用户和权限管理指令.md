用户和权限的问题在各种系统中都有涉及。要说设计的比较完美的，那就是Linux的用户权限管理了，其设计思想也被引用到各处。借着重学操作系统的机会，梳理一下这块的知识。内容摘自拉钩教育《[重学操作系统](重学操作系统)》

# 权限抽象
一个完整的权限管理体系，要有合理的抽象。这里就包括对用户、进程、文件、内存、系统调用等抽象

Linux 是一个多用户平台，允许多个用户同时登录系统工作。Linux 将用户抽象成了账户，账户可以登录系统，比如通过输入登录名 + 密码的方式登录；也可以通过证书的方式登录。但为了方便分配每个用户的权限，Linux 还支持组 （Group）账户。组账户是多个账户的集合，组可以为成员们分配某一类权限。每个用户可以在多个组，这样就可以利用组给用户快速分配权限。

此外，Linux 还对文件进行了权限抽象（注意目录也是一种文件）。Linux 中一个文件可以设置下面 3 种权限：

* 读权限（r）：控制读取文件。
* 写权限（w）：控制写入文件。
* 执行权限（x）：控制将文件执行，比如脚本、应用程序等。

然后每个文件又可以从 3 个维度去配置上述的 3 种权限：
* 用户维度。每个文件可以所属 1 个用户，用户维度配置的 rwx 在用户维度生效；
* 组维度。每个文件可以所属 1 个分组，组维度配置的 rwx 在组维度生效；
* 全部用户维度。设置对所有用户的权限。

因此 Linux 中文件的权限可以用 9 个字符，3 组rwx描述：第一组是用户权限，第二组是组权限，第三组是所有用户的权限。然后用-代表没有权限。比如rwxrwxrwx代表所有维度可以读写执行。rw--wxr-x代表用户维度不可以执行，组维度不可以读取，所有用户维度不可以写入。

## 思考题
1. 文件被创建后，初始的权限如何设置？
2. 需要全部用户都可以执行的指令，比如ls，它们的权限如何分配？
3. 给一个文本文件分配了可执行权限会怎么样？
4. 可不可以多个用户都登录root，然后只用root账户？
### 初始化权限问题
一个文件创建后，文件的所属用户会被设置成创建文件的用户。谁创建谁拥有

这里 Linux 想到了一个很好的办法，就是为每个用户创建一个同名分组。
比如说zhang这个账户创建时，会创建一个叫作zhang的分组。zhang登录之后，工作分组就会默认使用它的同名分组zhang。如果zhang想要切换工作分组，可以使用newgrp指令切换到另一个工作分组。因此，被创建文件所属的分组是当时用户所在的工作分组，如果没有特别设置，那么就属于用户所在的同名分组。

文件被创建后的权限通常是：rw-rw-r--
也就是用户、组维度不可以执行，所有用户可读。
### 公共执行文件的权限
用ls -l查看ls的权限，可以看到下图所示：
![image.png](http://140.143.145.178:8090/upload/2020/12/image-4053d8c9b40f4bc1ad6c59c888ab12c0.png)
第一个-代表这是一个普通文件，后面的 rwx 代表用户维度可读写和执行；第二个r-x代表组维度不可以写；第三个r-x代表所有用户可以读和执行。后面的两个root，第一个是所属用户，第二个是所属分组。

到这里你可能会有一个疑问：如果一个文件设置为不可读，但是可以执行，那么结果会怎样？

答案当然是不可以执行，无法读取文件内容自然不可以执行。
### 执行文件
在 Linux 中，如果一个文件可以被执行，则可以直接通过输入文件路径（相对路径或绝对路径）的方式执行。如果想执行一个不可以执行的文件，Linux 则会报错。

当用户输入一个文件名，如果没有指定完整路径，Linux 就会在一部分目录中查找这个文件。你可以通过echo $PATH看到 Linux 会在哪些目录中查找可执行文件，PATH是 Linux 的环境变量
### 可不可以多个用户都登录root
待整理。。。。。。
# 权限架构思想
优秀的架构，应该遵循最小权限原则（Least Privilege)。权限设计需要保证系统的安全和稳定。比如：每一个成员拥有的权限应该足够的小，每一段特权程序执行的过程应该足够的短。对于安全级别较高的时候，还需要成员权限互相牵制。比如金融领域通常登录线上数据库需要两次登录，也就是需要两个密码，分别掌握在两个角色手中。这样即便一个成员出了问题，也可以保证整个系统安全。

## 权限划分
权限架构思想还应遵循一个原则，权限划分边界应该足够清晰，尽量做到相互隔离。Linux 提供了用户和分组。当然 Linux 没有强迫你如何划分权限，这是为了应对更多的场景。通常我们服务器上重要的应用，会由不同的账户执行。比如说 Nginx、Web 服务器、数据库不会执行在一个账户下。现在随着容器化技术的发展，我们甚至希望每个应用独享一个虚拟的空间，就好像运行在一个单独的操作系统中一样，让它们互相不用干扰。
**为什么不用 root 账户执行程序？**
举个例子，你有一个 Mysql 进程执行在 root（最大权限）账户上，如果有黑客攻破了你的 Mysql 服务，获得了在 Mysql 上执行 Sql 的权限，那么，你的整个系统就都暴露在黑客眼前了。这会导致非常严重的后果。

黑客可以利用 Mysql 的 Copy From Prgram 指令为所欲为，比如先备份你的关键文件，然后再删除他们，并要挟你通过指定账户打款。如果执行最小权限原则，那么黑客即便攻破我们的 Mysql 服务，他也只能获得最小的权限。当然，黑客拿到 Mysql 权限也是非常可怕的，但是相比拿到所有权限，这个损失就小多了。
### 权限包围（Privilege Bracking）

之前我们讨论过，当 Mysql 跑在 root 权限时，如果 Mysql 被攻破，整个机器就被攻破了。因此我们所有应用都不要跑在 root 上。如果所有应用都跑在普通账户下，那么就会有临时提升权限的场景。比如说安装程序可能需要临时拥有管理员权限，将应用装到/usr/bin目录下。

Linux 提供了权限包围的能力。比如一个应用，临时需要高级权限，可以利用交互界面（比如让用户输入 root 账户密码）验证身份，然后执行需要高级权限的操作，然后马上恢复到普通权限工作。这样做可以减少应用在高级权限的时间，并做到专权专用，防止被恶意程序利用。

## 用户分组指令
### 查看分组 groups
![image.png](http://140.143.145.178:8090/upload/2020/12/image-a16f8c7132824c4a96c8459c84d8ef7e.png)
![image.png](http://140.143.145.178:8090/upload/2020/12/image-ff105e1df468400d9f2f7e7b690337ce.png)
### 查看当前用户 id
![image.png](http://140.143.145.178:8090/upload/2020/12/image-7c42e706409f4c9eb8fc27d0b885d883.png)
* uid 是用户 id；
* gid 是组 id；
* groups 后面是每个分组和分组的 id。
### 查看所有用户 cat /ets/passwd
这个文件存储了所有用户的信息
![image.png](http://140.143.145.178:8090/upload/2020/12/image-9f0e82728aa944e3896ff450c1f8c881.png)
![image.png](http://140.143.145.178:8090/upload/2020/12/image-bf8d4a02930347528caf2e730429bc2a.png)
### 创建用户 useradd
### 创建分组 groupadd 
#### 为用户添加次级分组
组分主要分组（Primary Group）和次级分组（Secondary Group）。主要分组只有 1 个，次级分组可以有多个。如果想为用户添加一个次级分组，可以用usermod指令。下面指令将用户foo添加到sudo分组，从而foo拥有了sudo的权限。
```
sudo usermod -a -G sudo foo
```
-a代表append，-G代表一个次级分组的清单， 最后一个foo是账户名。
### 修改用户主要分组
修改主要分组还是使用usermod指令。只不过参数是小写的-g。
```
sudo usermod -g somegroup foo
```
## 文件权限管理指令
### 查看文件权限 ls -l
### 修改文件权限 chmod
### 修改文件所属用户 chmon 
```
修改foo文件所属的用户为bar
chown bar ./foo
```

# 总结
**请简述 Linux 权限划分的原则**

每个用户掌握的权限应该足够小，每个组掌握的权限也足够小。实际生产过程中，最好管理员权限可以拆分，互相牵制防止问题。

每个应用应当尽可能小的使用权限。最理想的是每个应用单独占用一个容器（比如 Docker），这样就不存在互相影响的问题。即便应用被攻破，也无法攻破 Docker 的保护层。

尽可能少的root。如果一个用户需要root能力，那么应当进行权限包围——马上提升权限（比如 sudo），处理后马上释放权限。

系统层面实现权限分级保护，将系统的权限分成一个个 Ring，外层 Ring 调用内层 Ring 时需要内层 Ring 进行权限校验。
