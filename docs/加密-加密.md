# 摘要、加密与签名
**摘要**也称之为数字摘要（Digital Digest）或数字指纹（Digital Fingerprint）。JWT 令牌中默认的签名信息是对令牌头、负载和密钥三者通过令牌头中指定的哈希算法（HMAC SHA256）计算出来的摘要值，如下所示：
```
signature = SHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload) , secret)
```
理想的哈希算法都具备两个特性：一是易变性，这是指算法的输入端发生了任何一点细微变动，都会引发雪崩效应（Avalanche Effect），使得输出端的结果产生极大的变化。这个特性常被用来做校验，保护信息未被篡改，譬如互联网上下载大文件，常会附有一个哈希校验码，以确保下载下来的文件没有因网络或其他原因与原文件产生任何偏差。二是不可逆性，摘要的过程是单向的，不可能从摘要的结果中逆向还原出输入值来。这点只要具备初中数学知识就能想明白，世间的信息有无穷多种，而摘要的结果无论其位数是 32、128、512 Bits，再大也总归是个有限的数字，因此输入数据与输出的摘要结果必然不是一一对应的关系，如果我把一部电影做摘要形成 256 Bits 的哈希值，应该没有人会指望能从这个哈希值中还原出一部电影的。偶尔能听到 MD5、SHA1 或其他哈希算法被破解了的新闻，这里的“破解”并不是“解密”的意思，而是指找到了该算法的高效率碰撞方法，能够在合理的时间内生成两个摘要结果相同的输入比特流，但并不能指定这两个输入流中的某一个，更不代表碰撞产生的比特流就会是原来的输入源。

由这两个特点可见，摘要的意义是在源信息不泄漏的前提下辨别其真伪。易变性保证了从公开的特征上可以甄别出是否来自于源信息，不可逆性保证了从公开的特征并不会暴露出源信息，这与今天用做身份甄别的指纹、面容和虹膜的生物特征是具有高度可比性的。在一些场合中，摘要也会被借用来做加密（如保密中介绍的慢哈希 Bcrypt 算法）和签名（如 JWT 签名中的 HMAC SHA256 算法），但在严格意义上看，摘要与这两者是有本质的区别。

**加密**与摘要的本质区别在于加密是可逆的，逆过程就是解密。在经典密码学时代，加密的安全主要是依靠机密性来保证的，即依靠保护加密算法或算法的执行参数不被泄漏来保障信息的安全。而现代密码学不依靠机密性，加解密算法都是完全公开的，安全建立在特定问题的计算复杂度之上，具体是指算法根据输入端计算输出结果耗费的算力资源很小，但根据输出端的结果反过来推算原本的输入，耗费的算力就极其庞大。一个经常在课堂中用来说明计算复杂度的例子是大数的质因数分解.
根据加密与解密是否采用同一个密钥，现代密码学算法可分为*对称加密算法和非对称加密*两大类型，这两类算法各自有很明确的优劣势与应用场景。对称加密的缺点显而易见，加密和解密使用相同的密钥，当通信的成员数量增加时，为保证两两通信都都采用独立的密钥，密钥数量就与成员数量的平方成正比，这必然面临密钥管理的难题。而更尴尬的难题是当通信双方原本就不存在安全的信道时，如何才能将一个只能让通信双方才能知道的密钥传输给对方？如果有通道可以安全地传输密钥，那为何不使用现有的通道传输信息？这个“蛋鸡悖论”曾在很长的时间里严重阻碍了密码学在真实世界中推广应用。

20 世纪 70 年代中后期出现的非对称加密算法从根本上解决了密钥分发的难题，它将密钥分成公钥和私钥，公钥可以完全公开，无须安全传输的保证。私钥由用户自行保管，不参与任何通信传输。根据这两个密钥加解密方式的不同，使得算法可以提供两种不同的功能：

* **公钥加密，私钥解密，这种就是加密**，用于向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知。如果甲想给乙发一个安全保密的数据，那么应该甲乙各自有一个私钥，甲先用乙的公钥加密这段数据，再用自己的私钥加密这段加密后的数据。最后再发给乙，这样确保了内容即不会被读取，也不能被篡改。

* **私钥加密，公钥解密，这种就是签名**，用于让所有公钥所有者验证私钥所有者的身份，并且用来防止私钥所有者发布的内容被篡改。但是不用来保证内容不被他人获得。

这两种用途理论上肯定是成立的，现实中却一般不成立，单靠非对称加密算法，既做不了加密也做不了签名。原因是不论是加密还是解密，非对称加密算法的计算复杂度都相当高，性能比对称加密要差上好几个数量级（不是好几倍）。加解密性能不仅影响速度，还导致了现行的非对称加密算法都没有支持分组加密模式。分组是指由于明文长度与密钥长度在安全上具有相关性，通俗地说就是多长的密钥决定了它能加密多长的明文，如果明文太短就需要进行填充，太长就需要进行分组。因非对称加密本身的效率所限，难以支持分组，所以主流的非对称加密算法都只能加密不超过密钥长度的数据，这决定了非对称加密不能直接用于大量数据的加密。


# 对称&非对称结合使用
在加密方面，现在一般会结合对称与非对称加密的优点，以混合加密来保护信道安全，具体做法是用非对称加密来安全地传递少量数据给通信的另一方，然后再以这些数据为密钥，采用对称加密来安全高效地大量加密传输数据，这种由多种加密算法组合的应用形式被称为“密码学套件”。非对称加密在这个场景中发挥的作用称为“密钥协商”。

在签名方面，现在一般会结合摘要与非对称加密的优点，以对摘要结果做加密的形式来保证签名的适用性。由于对任何长度的输入源做摘要之后都能得到固定长度的结果，所以只要对摘要的结果进行签名，即相当于对整个输入源进行了背书，保证一旦内容遭到篡改，摘要结果就会变化，签名也就马上失效了。
```java
    
    /**
     * 处理请求数据
     *
     * @param commonData 普通数据，不需要加密
     * @param requestData 敏感数据，需要加密
     * @param publicKey 对方公钥
     * @param privateKey 自己私钥
     * @return
     * @throws Exception
     */
    public static JSONObject requestProcess(JSONObject commonData, JSONObject requestData, String publicKey, String privateKey) throws Exception {
         //传输数据
        JSONObject requestJson = new JSONObject();
        //获取安全随机数SecureRandom实现，作为对称加密的密钥
        String aesRandomKey = AlgorithmUtil.getAESRandomKey();
        //基于非对称加密RSA算法使用对方公钥加密随机数
        String randomKeyEncrypted = AlgorithmUtil.encryptWithRSA(aesRandomKey, publicKey);
        //使用随机数作为密钥，对称加密敏感数据
        String parameterJsonEncrypted = AlgorithmUtil.encryptWithAES(requestData.toJSONString(), aesRandomKey);

        requestJson.put("randomKeyEncrypted", randomKeyEncrypted);
        requestJson.put("bizData", parameterJsonEncrypted);
        requestJson.putAll(commonData);

        // 对数据签名
        //如果 数据比较大可以先对requestJson取摘要结果，再对摘要进行签名
        String signData = AlgorithmUtil.sign(SortUtil.getNatureSortedJSONObject(requestJson).toJSONString(), privateKey);
        requestJson.put("signature", signData);
        return requestJson;
```

三种密码学算法的对比
![捕获.PNG](https://github.com/oh-huohou/huohou.blog/blob/main/image/%E6%8D%95%E8%8E%B7-e4c7ae9fe26a4a4c9e0ec690f1ee82d0.PNG)

文字摘自：[凤凰架构](https://icyfenix.cn/architect-perspective/general-architecture/system-security/transport-security.html#%E6%91%98%E8%A6%81%E3%80%81%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%AD%BE%E5%90%8D)
代码来自：工作中与银行对接的案例
