# 算法简介：
一种基于消息传递的、具有高容错性的一致性算法
**解决问题：** 在分布式系统中如何就某个决议达成一致。
 
Paxos算法的前提是不存在拜占庭将军问题，即信道是安全的可靠的，集群节点间传递的信息是不会被篡改的。在实际工程实践中，大多数系统都是部署再一个局域网内，因此消息被篡改的情况很少；另一方面，由于硬件和网络原因而造成的消息不完整问题现在已经不是问题，只需要一套简单的校验算法即可，因此在实际工程中各个服务器间消息传递过程可以认为不存在拜占庭将军问题。

一般情况下，分布式系统中各个节点间采用两种通讯模型：共享内存、消息传递。Paxos是基于消息传递通讯模型的
# 算法描述：
## 三种角色
1. Proposer：提案的提议者
2. Acceptor：提案的表决者，即是否接收该提案。只有半数以上的Acceptor接受了某提案，那么该提案则被认定为选定
3. Learner：提案的学习者。当提案被选定后，其会同步并执行提案

表决者和提议者有可能存在多个，不同的提议者会提出不同的提案，而一致性算法则可以保证如下几点：
1. 没有提案被提出则不会有提案被选定
2. 每个提议者在提出提案时都会为该提案指定一个具有全局唯一性的递增的提案编号N，即在整个集群中是唯一的
3. 每个表决者在接受某提案后会将该提案的编号N记录在本地，这样每个表决者中保存的已经被接受的提案会存在一个编号最大的提案，起编号假设为maxN，每个表决者仅会接受编号大于自己的本地maxN的提案
4. 在众多提案中最终只能有一个提案被选定
5. 一旦一个提案被选定，则其他服务器会主动同步该提案到本地

## 过程描述
### A、prepare阶段
1. 提议者(Proposer)准备提交一个编号为N的提议，于是其向所有表决者(Acceptor)发送prepare(N)请求，用于试探集群是否支持该编号的提议
2. 每个表决者Acceptor中都保存着自己曾经accept过的提议中最大的编号maxN。当一个表决者接收到其他主机发送来的prepare(N)请求时，其会比较N与maxN的值。若N小于maxN，则说明该提议已过时，当前表决者采取不回应或回应Error的方式来拒绝该prepare(N)请求；若N大于maxN，则说明该提议是可以接受的，当前表决者会将其曾经已经accept的编号最大提案proposal(myid,maxN,value)反馈给提议者，以向提议者展示自己支持的提案意愿。其中第一个参数myid表示表决者Acceptor的标识id，第二个参数表示其曾接受的提案的最大编号maxN，第三个参数表示该提案的真正内容value。当然，若当前表决者还未曾accept过任何提议，则会将Proposal(myid,null,null)反馈给提议者。
### B、accept阶段
1. 当提议者proposer发出prepare(N)后，若收到了超过半数的表决者(Acceptor)的反馈那么该提议者就会将其真正的提案Proposal(N,value)发送给所有的表决者。
2. 当表决者Acceptor接收到提议者发送的Proposal(N,value)提案后，会再次拿出自己曾经accept过的提议中最大编号maxN，及曾经反馈过的prepare的最大编号，让N与他们进行比较，若N大于等于这两个编号，则当前表决者accep该提案并反馈给提议者。若N小于这两个编号，则表决者采取不回应或回应Error的方式来拒绝该提议。
3. 若提议者没有接收到超过半数的表决者的accept反馈则重新进入prepare阶段，递增提案号，重新提出prepare请求。若提议者接收到反馈数量超过了半数则其他的未向提议者发送accept反馈的表决者将成为Learner,主动同步提议者的该提案。




参考：开课吧某公开课
